
==================== FINAL INTERFACE ====================
2015-10-03 17:11:11.788941 UTC

interface compi_67JlvSkZUoW2a5wLn384Tq:JackParser.Lexer 7102
  interface hash: cdc1d548a463965f79bb5453ef0ac464
  ABI hash: 530b85fe2b24277601c13edea12f76d7
  export-list hash: ceb265d750e2ba0bb23743e627e31c17
  orphan hash: c1f3b841d82eda14b92d3f940d9d364d
  flag hash: 3e6fb97481ca3c41c4e9e8ac02c8acab
  sig of: Nothing
  used TH splices: False
  where
exports:
  JackParser.Lexer.bAOp
  JackParser.Lexer.bBOp
  JackParser.Lexer.blockC
  JackParser.Lexer.boolean
  JackParser.Lexer.braces
  JackParser.Lexer.brackets
  JackParser.Lexer.cmt
  JackParser.Lexer.comma
  JackParser.Lexer.commaSep
  JackParser.Lexer.funType
  JackParser.Lexer.identifier
  JackParser.Lexer.integer
  JackParser.Lexer.languageDef
  JackParser.Lexer.lexeme
  JackParser.Lexer.lexer
  JackParser.Lexer.lineC
  JackParser.Lexer.parens
  JackParser.Lexer.rBOp
  JackParser.Lexer.reserved
  JackParser.Lexer.reservedOp
  JackParser.Lexer.scope
  JackParser.Lexer.semi
  JackParser.Lexer.stringLiteral
  JackParser.Lexer.ttypes
  JackParser.Lexer.uAOp
  JackParser.Lexer.uBOp
  JackParser.Lexer.whiteSpace
  JackParser.Lexer.BAOp{JackParser.Lexer.Add JackParser.Lexer.Div JackParser.Lexer.Mult JackParser.Lexer.Sub}
  JackParser.Lexer.BBOp{JackParser.Lexer.And JackParser.Lexer.Or}
  JackParser.Lexer.BOp{JackParser.Lexer.BA JackParser.Lexer.BB JackParser.Lexer.RB}
  JackParser.Lexer.Boolean{JackParser.Lexer.F JackParser.Lexer.T}
  JackParser.Lexer.Comment
  JackParser.Lexer.FunType{JackParser.Lexer.Constructor JackParser.Lexer.Function JackParser.Lexer.Method}
  JackParser.Lexer.Identifier
  JackParser.Lexer.IntLit
  JackParser.Lexer.RBOp{JackParser.Lexer.Eq JackParser.Lexer.Gt JackParser.Lexer.Lt}
  JackParser.Lexer.Scope{JackParser.Lexer.Argument JackParser.Lexer.Field JackParser.Lexer.Local JackParser.Lexer.Static}
  JackParser.Lexer.TType
  JackParser.Lexer.UAOp{JackParser.Lexer.Neg}
  JackParser.Lexer.UBOp{JackParser.Lexer.Not}
  JackParser.Lexer.UOp{JackParser.Lexer.UA JackParser.Lexer.UB}
  JackParser.Lexer.VarType
module dependencies:
package dependencies: array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      base-4.8.1.0* binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0
                      text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
import  -/  base-4.8.1.0:Data.Functor 5c701b0af1708f0192a25dfe14ce6274
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  base-4.8.1.0:Text.Read 30509137a501bd56d136aca29a7a35a6
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0:Text.Parsec.Char afe4c37d8611a25041c84760b717c602
import  -/  parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0:Text.Parsec.Combinator 69f5c1efe41ef6c39f8bbae8eebb0a80
import  -/  parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0:Text.Parsec.Language abb26ce5af2f03525d1362724abafd24
import  -/  parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0:Text.Parsec.Prim 285cde77b6b24df2175f0525c84910d8
import  -/  parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0:Text.Parsec.String 4b7d1159848b56228c8c8ce8ab90dc5a
import  -/  parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0:Text.Parsec.Token a90d4307ac14825fb5f50e3c43003034
import  -/  parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0:Text.ParserCombinators.Parsec fed41157d76515d041e8b89ebc51bfb3
import  -/  parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0:Text.ParserCombinators.Parsec.Expr c27585a883c37ec85aa555793139c449
import  -/  parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0:Text.ParserCombinators.Parsec.Language a97b805eb594ac5775036ef8828f3c11
import  -/  parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0:Text.ParserCombinators.Parsec.Prim cf697a923b1eab44702b03a1563df2f8
import  -/  parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0:Text.ParserCombinators.Parsec.Token c60f89a2888411f410de13f8f5b386b8
4ceb7307f8ee08c3bdebb363f9dd3cb6
  $fEqBAOp :: GHC.Classes.Eq JackParser.Lexer.BAOp
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.BAOp
                  JackParser.Lexer.$fEqBAOp_$c==
                  JackParser.Lexer.$fEqBAOp_$c/= -}
4ceb7307f8ee08c3bdebb363f9dd3cb6
  $fEqBAOp_$c/= ::
    JackParser.Lexer.BAOp -> JackParser.Lexer.BAOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: JackParser.Lexer.BAOp
                   b :: JackParser.Lexer.BAOp ->
                 case a8 of wild {
                   JackParser.Lexer.Add
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True JackParser.Lexer.Add -> GHC.Types.False }
                   JackParser.Lexer.Sub
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True JackParser.Lexer.Sub -> GHC.Types.False }
                   JackParser.Lexer.Mult
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        JackParser.Lexer.Mult -> GHC.Types.False }
                   JackParser.Lexer.Div
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        JackParser.Lexer.Div -> GHC.Types.False } }) -}
4ceb7307f8ee08c3bdebb363f9dd3cb6
  $fEqBAOp_$c== ::
    JackParser.Lexer.BAOp -> JackParser.Lexer.BAOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: JackParser.Lexer.BAOp
                   ds1 :: JackParser.Lexer.BAOp ->
                 case ds of wild {
                   JackParser.Lexer.Add
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False JackParser.Lexer.Add -> GHC.Types.True }
                   JackParser.Lexer.Sub
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False JackParser.Lexer.Sub -> GHC.Types.True }
                   JackParser.Lexer.Mult
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.Mult -> GHC.Types.True }
                   JackParser.Lexer.Div
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.Div -> GHC.Types.True } }) -}
466d0d1969976101807d66ed5c06e1dc
  $fEqBBOp :: GHC.Classes.Eq JackParser.Lexer.BBOp
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.BBOp
                  JackParser.Lexer.$fEqBBOp_$c==
                  JackParser.Lexer.$fEqBBOp_$c/= -}
466d0d1969976101807d66ed5c06e1dc
  $fEqBBOp_$c/= ::
    JackParser.Lexer.BBOp -> JackParser.Lexer.BBOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: JackParser.Lexer.BBOp b :: JackParser.Lexer.BBOp ->
                 case a8 of wild {
                   JackParser.Lexer.And
                   -> case b of wild1 {
                        JackParser.Lexer.And -> GHC.Types.False
                        JackParser.Lexer.Or -> GHC.Types.True }
                   JackParser.Lexer.Or
                   -> case b of wild1 {
                        JackParser.Lexer.And -> GHC.Types.True
                        JackParser.Lexer.Or -> GHC.Types.False } }) -}
466d0d1969976101807d66ed5c06e1dc
  $fEqBBOp_$c== ::
    JackParser.Lexer.BBOp -> JackParser.Lexer.BBOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: JackParser.Lexer.BBOp ds1 :: JackParser.Lexer.BBOp ->
                 case ds of wild {
                   JackParser.Lexer.And
                   -> case ds1 of wild1 {
                        JackParser.Lexer.And -> GHC.Types.True
                        JackParser.Lexer.Or -> GHC.Types.False }
                   JackParser.Lexer.Or
                   -> case ds1 of wild1 {
                        JackParser.Lexer.And -> GHC.Types.False
                        JackParser.Lexer.Or -> GHC.Types.True } }) -}
53109870470fa3811ff03652ee2530bf
  $fEqBOp :: GHC.Classes.Eq JackParser.Lexer.BOp
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.BOp
                  JackParser.Lexer.$fEqBOp_$c==
                  JackParser.Lexer.$fEqBOp_$c/= -}
53109870470fa3811ff03652ee2530bf
  $fEqBOp_$c/= ::
    JackParser.Lexer.BOp -> JackParser.Lexer.BOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: JackParser.Lexer.BOp b :: JackParser.Lexer.BOp ->
                 case JackParser.Lexer.$fEqBOp_$c== a8 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
53109870470fa3811ff03652ee2530bf
  $fEqBOp_$c== ::
    JackParser.Lexer.BOp -> JackParser.Lexer.BOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: JackParser.Lexer.BOp
                   ds1 :: JackParser.Lexer.BOp ->
                 case ds of wild {
                   JackParser.Lexer.BA a8
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.BA b1 -> JackParser.Lexer.$fEqBAOp_$c== a8 b1 }
                   JackParser.Lexer.BB a8
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.BB b1 -> JackParser.Lexer.$fEqBBOp_$c== a8 b1 }
                   JackParser.Lexer.RB a8
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.RB b1
                        -> JackParser.Lexer.$fEqBOp_$c==1 a8 b1 } }) -}
7b5674010925f9dcd30e2dcad387229f
  $fEqBOp_$c==1 ::
    JackParser.Lexer.RBOp -> JackParser.Lexer.RBOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: JackParser.Lexer.RBOp ds1 :: JackParser.Lexer.RBOp ->
                 case ds of wild {
                   JackParser.Lexer.Eq
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False JackParser.Lexer.Eq -> GHC.Types.True }
                   JackParser.Lexer.Lt
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False JackParser.Lexer.Lt -> GHC.Types.True }
                   JackParser.Lexer.Gt
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.Gt -> GHC.Types.True } }) -}
5585d32fe30beb50bffa4cc11aa621ed
  $fEqBoolean :: GHC.Classes.Eq JackParser.Lexer.Boolean
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.Boolean
                  JackParser.Lexer.$fEqBoolean_$c==
                  JackParser.Lexer.$fEqBoolean_$c/= -}
5585d32fe30beb50bffa4cc11aa621ed
  $fEqBoolean_$c/= ::
    JackParser.Lexer.Boolean
    -> JackParser.Lexer.Boolean -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: JackParser.Lexer.Boolean b :: JackParser.Lexer.Boolean ->
                 case a8 of wild {
                   JackParser.Lexer.T
                   -> case b of wild1 {
                        JackParser.Lexer.T -> GHC.Types.False
                        JackParser.Lexer.F -> GHC.Types.True }
                   JackParser.Lexer.F
                   -> case b of wild1 {
                        JackParser.Lexer.T -> GHC.Types.True
                        JackParser.Lexer.F -> GHC.Types.False } }) -}
5585d32fe30beb50bffa4cc11aa621ed
  $fEqBoolean_$c== ::
    JackParser.Lexer.Boolean
    -> JackParser.Lexer.Boolean -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: JackParser.Lexer.Boolean
                   ds1 :: JackParser.Lexer.Boolean ->
                 case ds of wild {
                   JackParser.Lexer.T
                   -> case ds1 of wild1 {
                        JackParser.Lexer.T -> GHC.Types.True
                        JackParser.Lexer.F -> GHC.Types.False }
                   JackParser.Lexer.F
                   -> case ds1 of wild1 {
                        JackParser.Lexer.T -> GHC.Types.False
                        JackParser.Lexer.F -> GHC.Types.True } }) -}
fb7036306be5bcfd6aee8801cbc91af6
  $fEqFunType :: GHC.Classes.Eq JackParser.Lexer.FunType
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.FunType
                  JackParser.Lexer.$fEqFunType_$c==
                  JackParser.Lexer.$fEqFunType_$c/= -}
fb7036306be5bcfd6aee8801cbc91af6
  $fEqFunType_$c/= ::
    JackParser.Lexer.FunType
    -> JackParser.Lexer.FunType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: JackParser.Lexer.FunType b :: JackParser.Lexer.FunType ->
                 case a8 of wild {
                   JackParser.Lexer.Function
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        JackParser.Lexer.Function -> GHC.Types.False }
                   JackParser.Lexer.Method
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        JackParser.Lexer.Method -> GHC.Types.False }
                   JackParser.Lexer.Constructor
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        JackParser.Lexer.Constructor -> GHC.Types.False } }) -}
fb7036306be5bcfd6aee8801cbc91af6
  $fEqFunType_$c== ::
    JackParser.Lexer.FunType
    -> JackParser.Lexer.FunType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: JackParser.Lexer.FunType
                   ds1 :: JackParser.Lexer.FunType ->
                 case ds of wild {
                   JackParser.Lexer.Function
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.Function -> GHC.Types.True }
                   JackParser.Lexer.Method
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.Method -> GHC.Types.True }
                   JackParser.Lexer.Constructor
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.Constructor -> GHC.Types.True } }) -}
7b5674010925f9dcd30e2dcad387229f
  $fEqRBOp :: GHC.Classes.Eq JackParser.Lexer.RBOp
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.RBOp
                  JackParser.Lexer.$fEqBOp_$c==1
                  JackParser.Lexer.$fEqRBOp_$c/= -}
7b5674010925f9dcd30e2dcad387229f
  $fEqRBOp_$c/= ::
    JackParser.Lexer.RBOp -> JackParser.Lexer.RBOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: JackParser.Lexer.RBOp b :: JackParser.Lexer.RBOp ->
                 case a8 of wild {
                   JackParser.Lexer.Eq
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True JackParser.Lexer.Eq -> GHC.Types.False }
                   JackParser.Lexer.Lt
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True JackParser.Lexer.Lt -> GHC.Types.False }
                   JackParser.Lexer.Gt
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        JackParser.Lexer.Gt -> GHC.Types.False } }) -}
f640582c3ce4c1fa29e06a362c221588
  $fEqScope :: GHC.Classes.Eq JackParser.Lexer.Scope
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.Scope
                  JackParser.Lexer.$fEqScope_$c==
                  JackParser.Lexer.$fEqScope_$c/= -}
f640582c3ce4c1fa29e06a362c221588
  $fEqScope_$c/= ::
    JackParser.Lexer.Scope -> JackParser.Lexer.Scope -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: JackParser.Lexer.Scope
                   b :: JackParser.Lexer.Scope ->
                 case a8 of wild {
                   JackParser.Lexer.Field
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        JackParser.Lexer.Field -> GHC.Types.False }
                   JackParser.Lexer.Static
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        JackParser.Lexer.Static -> GHC.Types.False }
                   JackParser.Lexer.Local
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        JackParser.Lexer.Local -> GHC.Types.False }
                   JackParser.Lexer.Argument
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        JackParser.Lexer.Argument -> GHC.Types.False } }) -}
f640582c3ce4c1fa29e06a362c221588
  $fEqScope_$c== ::
    JackParser.Lexer.Scope -> JackParser.Lexer.Scope -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: JackParser.Lexer.Scope
                   ds1 :: JackParser.Lexer.Scope ->
                 case ds of wild {
                   JackParser.Lexer.Field
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.Field -> GHC.Types.True }
                   JackParser.Lexer.Static
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.Static -> GHC.Types.True }
                   JackParser.Lexer.Local
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.Local -> GHC.Types.True }
                   JackParser.Lexer.Argument
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        JackParser.Lexer.Argument -> GHC.Types.True } }) -}
e06ca1c44b5ca55a52b49f13e3f094fe
  $fEqUAOp :: GHC.Classes.Eq JackParser.Lexer.UAOp
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.UAOp
                  JackParser.Lexer.$fEqUAOp_$c==
                  JackParser.Lexer.$fEqUAOp_$c/= -}
e06ca1c44b5ca55a52b49f13e3f094fe
  $fEqUAOp_$c/= ::
    JackParser.Lexer.UAOp -> JackParser.Lexer.UAOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*H><S,1*H>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: JackParser.Lexer.UAOp b :: JackParser.Lexer.UAOp ->
                 case a8 of wild { JackParser.Lexer.Neg ->
                 case b of wild1 { JackParser.Lexer.Neg -> GHC.Types.False } }) -}
e06ca1c44b5ca55a52b49f13e3f094fe
  $fEqUAOp_$c== ::
    JackParser.Lexer.UAOp -> JackParser.Lexer.UAOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*H><S,1*H>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: JackParser.Lexer.UAOp ds1 :: JackParser.Lexer.UAOp ->
                 case ds of wild { JackParser.Lexer.Neg ->
                 case ds1 of wild1 { JackParser.Lexer.Neg -> GHC.Types.True } }) -}
5b4e4b914326506c05e696f27d3c09f5
  $fEqUBOp :: GHC.Classes.Eq JackParser.Lexer.UBOp
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.UBOp
                  JackParser.Lexer.$fEqUBOp_$c==
                  JackParser.Lexer.$fEqUBOp_$c/= -}
5b4e4b914326506c05e696f27d3c09f5
  $fEqUBOp_$c/= ::
    JackParser.Lexer.UBOp -> JackParser.Lexer.UBOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*H><S,1*H>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: JackParser.Lexer.UBOp b :: JackParser.Lexer.UBOp ->
                 case a8 of wild { JackParser.Lexer.Not ->
                 case b of wild1 { JackParser.Lexer.Not -> GHC.Types.False } }) -}
5b4e4b914326506c05e696f27d3c09f5
  $fEqUBOp_$c== ::
    JackParser.Lexer.UBOp -> JackParser.Lexer.UBOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*H><S,1*H>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: JackParser.Lexer.UBOp ds1 :: JackParser.Lexer.UBOp ->
                 case ds of wild { JackParser.Lexer.Not ->
                 case ds1 of wild1 { JackParser.Lexer.Not -> GHC.Types.True } }) -}
be410ceafbd8c6f0e883a2c57696dc8d
  $fEqUOp :: GHC.Classes.Eq JackParser.Lexer.UOp
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.UOp
                  JackParser.Lexer.$fEqUOp_$c==
                  JackParser.Lexer.$fEqUOp_$c/= -}
be410ceafbd8c6f0e883a2c57696dc8d
  $fEqUOp_$c/= ::
    JackParser.Lexer.UOp -> JackParser.Lexer.UOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: JackParser.Lexer.UOp
                   b :: JackParser.Lexer.UOp ->
                 case a8 of wild {
                   JackParser.Lexer.UA a9
                   -> case b of wild1 {
                        JackParser.Lexer.UA b1
                        -> case a9 of wild2 { JackParser.Lexer.Neg ->
                           case b1 of wild3 { JackParser.Lexer.Neg -> GHC.Types.False } }
                        JackParser.Lexer.UB ipv -> GHC.Types.True }
                   JackParser.Lexer.UB a9
                   -> case b of wild1 {
                        JackParser.Lexer.UA ipv -> GHC.Types.True
                        JackParser.Lexer.UB b1
                        -> case a9 of wild2 { JackParser.Lexer.Not ->
                           case b1 of wild3 { JackParser.Lexer.Not ->
                           GHC.Types.False } } } }) -}
be410ceafbd8c6f0e883a2c57696dc8d
  $fEqUOp_$c== ::
    JackParser.Lexer.UOp -> JackParser.Lexer.UOp -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: JackParser.Lexer.UOp
                   ds1 :: JackParser.Lexer.UOp ->
                 case ds of wild {
                   JackParser.Lexer.UA a8
                   -> case ds1 of wild1 {
                        JackParser.Lexer.UA b1
                        -> case a8 of wild2 { JackParser.Lexer.Neg ->
                           case b1 of wild3 { JackParser.Lexer.Neg -> GHC.Types.True } }
                        JackParser.Lexer.UB ipv -> GHC.Types.False }
                   JackParser.Lexer.UB a8
                   -> case ds1 of wild1 {
                        JackParser.Lexer.UA ipv -> GHC.Types.False
                        JackParser.Lexer.UB b1
                        -> case a8 of wild2 { JackParser.Lexer.Not ->
                           case b1 of wild3 { JackParser.Lexer.Not ->
                           GHC.Types.True } } } }) -}
4ceb7307f8ee08c3bdebb363f9dd3cb6
  $fShowBAOp :: GHC.Show.Show JackParser.Lexer.BAOp
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.BAOp
                  JackParser.Lexer.$fShowBAOp_$cshowsPrec
                  JackParser.Lexer.$fShowBAOp_$cshow
                  JackParser.Lexer.$fShowBAOp_$cshowList -}
26145b75ef0ab5a5373dbf26856e14ef
  $fShowBAOp1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "call Math.divide 2"#) -}
956449c3317be7ea7e575cd804336755
  $fShowBAOp2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "call Math.multiply 2"#) -}
f0aff3a793a3065ea8f2c5464ddbe891
  $fShowBAOp3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "sub"#) -}
33e6eb8417e3763cd85ed16d8338dd0b
  $fShowBAOp4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "add"#) -}
4ceb7307f8ee08c3bdebb363f9dd3cb6
  $fShowBAOp_$cshow :: JackParser.Lexer.BAOp -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: JackParser.Lexer.BAOp ->
                 case ds of wild {
                   JackParser.Lexer.Add -> JackParser.Lexer.$fShowBAOp4
                   JackParser.Lexer.Sub -> JackParser.Lexer.$fShowBAOp3
                   JackParser.Lexer.Mult -> JackParser.Lexer.$fShowBAOp2
                   JackParser.Lexer.Div -> JackParser.Lexer.$fShowBAOp1 }) -}
4ceb7307f8ee08c3bdebb363f9dd3cb6
  $fShowBAOp_$cshowList :: [JackParser.Lexer.BAOp] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ ls :: [JackParser.Lexer.BAOp] s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ JackParser.Lexer.BAOp
                   (JackParser.Lexer.$fShowBAOp_$cshowsPrec GHC.Show.shows18)
                   ls
                   s) -}
4ceb7307f8ee08c3bdebb363f9dd3cb6
  $fShowBAOp_$cshowsPrec ::
    GHC.Types.Int -> JackParser.Lexer.BAOp -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: JackParser.Lexer.BAOp
                   w2 :: GHC.Base.String ->
                 JackParser.Lexer.$w$cshowsPrec w1 w2) -}
466d0d1969976101807d66ed5c06e1dc
  $fShowBBOp :: GHC.Show.Show JackParser.Lexer.BBOp
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.BBOp
                  JackParser.Lexer.$fShowBBOp_$s$dmshowsPrec
                  JackParser.Lexer.$fShowBBOp_$cshow
                  JackParser.Lexer.$fShowBBOp_$cshowList -}
466d0d1969976101807d66ed5c06e1dc
  $fShowBBOp1 ::
    JackParser.Lexer.BBOp -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ x :: JackParser.Lexer.BBOp
                   s :: GHC.Base.String[OneShot] ->
                 case x of wild {
                   JackParser.Lexer.And
                   -> GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowBBOp3 s
                   JackParser.Lexer.Or
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        JackParser.Lexer.$fShowBBOp2
                        s }) -}
5fe31823090586b3bd0a1b17d331cbc2
  $fShowBBOp2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "or"#) -}
1c018ff0a262646e6a8d6394792eed84
  $fShowBBOp3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "and"#) -}
466d0d1969976101807d66ed5c06e1dc
  $fShowBBOp_$cshow :: JackParser.Lexer.BBOp -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: JackParser.Lexer.BBOp ->
                 case ds of wild {
                   JackParser.Lexer.And -> JackParser.Lexer.$fShowBBOp3
                   JackParser.Lexer.Or -> JackParser.Lexer.$fShowBBOp2 }) -}
466d0d1969976101807d66ed5c06e1dc
  $fShowBBOp_$cshowList :: [JackParser.Lexer.BBOp] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ ls :: [JackParser.Lexer.BBOp] s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ JackParser.Lexer.BBOp
                   JackParser.Lexer.$fShowBBOp1
                   ls
                   s) -}
466d0d1969976101807d66ed5c06e1dc
  $fShowBBOp_$s$dmshowsPrec ::
    GHC.Types.Int -> JackParser.Lexer.BBOp -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (-1, True, False)
                (\ ds :: GHC.Types.Int
                   x :: JackParser.Lexer.BBOp
                   s :: GHC.Base.String ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (JackParser.Lexer.$fShowBBOp_$cshow x))
                   s) -}
53109870470fa3811ff03652ee2530bf
  $fShowBOp :: GHC.Show.Show JackParser.Lexer.BOp
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.BOp
                  JackParser.Lexer.$fShowBOp_$cshowsPrec
                  JackParser.Lexer.$fShowBOp_$cshow
                  JackParser.Lexer.$fShowBOp_$cshowList -}
53109870470fa3811ff03652ee2530bf
  $fShowBOp1 ::
    JackParser.Lexer.BOp -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ x :: JackParser.Lexer.BOp
                   s :: GHC.Base.String[OneShot] ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (JackParser.Lexer.$fShowBOp_$cshow x)
                   s) -}
431fbe5ba524cfbc7e7657275cc3c019
  $fShowBOp2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "gt"#) -}
6e0d9a0edfb4a38d5317140482e79524
  $fShowBOp3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "lt"#) -}
14557dc1b04c4e85d11b37252f5a0cde
  $fShowBOp4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "eq"#) -}
53109870470fa3811ff03652ee2530bf
  $fShowBOp_$cshow :: JackParser.Lexer.BOp -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: JackParser.Lexer.BOp ->
                 case ds of wild {
                   JackParser.Lexer.BA x -> JackParser.Lexer.$fShowBAOp_$cshow x
                   JackParser.Lexer.BB x
                   -> case x of wild1 {
                        JackParser.Lexer.And -> JackParser.Lexer.$fShowBBOp3
                        JackParser.Lexer.Or -> JackParser.Lexer.$fShowBBOp2 }
                   JackParser.Lexer.RB x -> JackParser.Lexer.$fShowBOp_$cshow1 x }) -}
7b5674010925f9dcd30e2dcad387229f
  $fShowBOp_$cshow1 :: JackParser.Lexer.RBOp -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: JackParser.Lexer.RBOp ->
                 case ds of wild {
                   JackParser.Lexer.Eq -> JackParser.Lexer.$fShowBOp4
                   JackParser.Lexer.Lt -> JackParser.Lexer.$fShowBOp3
                   JackParser.Lexer.Gt -> JackParser.Lexer.$fShowBOp2 }) -}
53109870470fa3811ff03652ee2530bf
  $fShowBOp_$cshowList :: [JackParser.Lexer.BOp] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ ls :: [JackParser.Lexer.BOp] s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ JackParser.Lexer.BOp
                   JackParser.Lexer.$fShowBOp1
                   ls
                   s) -}
53109870470fa3811ff03652ee2530bf
  $fShowBOp_$cshowsPrec ::
    GHC.Types.Int -> JackParser.Lexer.BOp -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   x :: JackParser.Lexer.BOp
                   s :: GHC.Base.String ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (JackParser.Lexer.$fShowBOp_$cshow x))
                   s) -}
5585d32fe30beb50bffa4cc11aa621ed
  $fShowBoolean :: GHC.Show.Show JackParser.Lexer.Boolean
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.Boolean
                  JackParser.Lexer.$fShowBoolean_$s$dmshowsPrec
                  JackParser.Lexer.$fShowBoolean_$cshow
                  JackParser.Lexer.$fShowBoolean_$cshowList -}
5585d32fe30beb50bffa4cc11aa621ed
  $fShowBoolean1 ::
    JackParser.Lexer.Boolean -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ x :: JackParser.Lexer.Boolean
                   s :: GHC.Base.String[OneShot] ->
                 case x of wild {
                   JackParser.Lexer.T
                   -> GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowBoolean3 s
                   JackParser.Lexer.F
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        JackParser.Lexer.$fShowBoolean2
                        s }) -}
532e9d358771d8c84d0fb5fdd30e1105
  $fShowBoolean2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "0"#) -}
272e08458801a26131c5aa70c8426cd8
  $fShowBoolean3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "-1"#) -}
5585d32fe30beb50bffa4cc11aa621ed
  $fShowBoolean_$cshow :: JackParser.Lexer.Boolean -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: JackParser.Lexer.Boolean ->
                 case ds of wild {
                   JackParser.Lexer.T -> JackParser.Lexer.$fShowBoolean3
                   JackParser.Lexer.F -> JackParser.Lexer.$fShowBoolean2 }) -}
5585d32fe30beb50bffa4cc11aa621ed
  $fShowBoolean_$cshowList ::
    [JackParser.Lexer.Boolean] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ ls :: [JackParser.Lexer.Boolean]
                   s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ JackParser.Lexer.Boolean
                   JackParser.Lexer.$fShowBoolean1
                   ls
                   s) -}
5585d32fe30beb50bffa4cc11aa621ed
  $fShowBoolean_$s$dmshowsPrec ::
    GHC.Types.Int -> JackParser.Lexer.Boolean -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (-1, True, False)
                (\ ds :: GHC.Types.Int
                   x :: JackParser.Lexer.Boolean
                   s :: GHC.Base.String ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (JackParser.Lexer.$fShowBoolean_$cshow x))
                   s) -}
fb7036306be5bcfd6aee8801cbc91af6
  $fShowFunType :: GHC.Show.Show JackParser.Lexer.FunType
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.FunType
                  JackParser.Lexer.$fShowFunType_$cshowsPrec
                  JackParser.Lexer.$fShowFunType_$cshow
                  JackParser.Lexer.$fShowFunType_$cshowList -}
d4763ba19e6b37b40d946c34579ec895
  $fShowFunType1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Constructor"#) -}
ae8e871b788803caaa08c68471e971ef
  $fShowFunType2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Method"#) -}
d62d063212333b0674843f489a869ddf
  $fShowFunType3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Function"#) -}
fb7036306be5bcfd6aee8801cbc91af6
  $fShowFunType_$cshow :: JackParser.Lexer.FunType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: JackParser.Lexer.FunType ->
                 case x of wild {
                   JackParser.Lexer.Function -> JackParser.Lexer.$fShowFunType3
                   JackParser.Lexer.Method -> JackParser.Lexer.$fShowFunType2
                   JackParser.Lexer.Constructor
                   -> JackParser.Lexer.$fShowFunType1 }) -}
fb7036306be5bcfd6aee8801cbc91af6
  $fShowFunType_$cshowList ::
    [JackParser.Lexer.FunType] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ JackParser.Lexer.FunType
                   JackParser.Lexer.$w$cshowsPrec1) -}
fb7036306be5bcfd6aee8801cbc91af6
  $fShowFunType_$cshowsPrec ::
    GHC.Types.Int -> JackParser.Lexer.FunType -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: JackParser.Lexer.FunType
                   w2 :: GHC.Base.String ->
                 JackParser.Lexer.$w$cshowsPrec1 w1 w2) -}
7b5674010925f9dcd30e2dcad387229f
  $fShowRBOp :: GHC.Show.Show JackParser.Lexer.RBOp
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.RBOp
                  JackParser.Lexer.$fShowRBOp_$cshowsPrec
                  JackParser.Lexer.$fShowBOp_$cshow1
                  JackParser.Lexer.$fShowRBOp_$cshowList -}
7b5674010925f9dcd30e2dcad387229f
  $fShowRBOp_$cshowList :: [JackParser.Lexer.RBOp] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ ls :: [JackParser.Lexer.RBOp] s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ JackParser.Lexer.RBOp
                   (JackParser.Lexer.$fShowRBOp_$cshowsPrec GHC.Show.shows18)
                   ls
                   s) -}
7b5674010925f9dcd30e2dcad387229f
  $fShowRBOp_$cshowsPrec ::
    GHC.Types.Int -> JackParser.Lexer.RBOp -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: JackParser.Lexer.RBOp
                   w2 :: GHC.Base.String ->
                 JackParser.Lexer.$w$cshowsPrec2 w1 w2) -}
f640582c3ce4c1fa29e06a362c221588
  $fShowScope :: GHC.Show.Show JackParser.Lexer.Scope
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.Scope
                  JackParser.Lexer.$fShowScope_$cshowsPrec
                  JackParser.Lexer.$fShowScope_$cshow
                  JackParser.Lexer.$fShowScope_$cshowList -}
f28dded6a1db9abcf2c1b85e898a47e8
  $fShowScope1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "argument"#) -}
1a406c19331c80d6bff11db8ede45bad
  $fShowScope2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "local"#) -}
a00d96c054bc44931c5f39f71b9e1ca0
  $fShowScope3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "static"#) -}
39b36b9dd5f03ba7d4846a7c1722c2db
  $fShowScope4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "this"#) -}
f640582c3ce4c1fa29e06a362c221588
  $fShowScope_$cshow :: JackParser.Lexer.Scope -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: JackParser.Lexer.Scope ->
                 case ds of wild {
                   JackParser.Lexer.Field -> JackParser.Lexer.$fShowScope4
                   JackParser.Lexer.Static -> JackParser.Lexer.$fShowScope3
                   JackParser.Lexer.Local -> JackParser.Lexer.$fShowScope2
                   JackParser.Lexer.Argument -> JackParser.Lexer.$fShowScope1 }) -}
f640582c3ce4c1fa29e06a362c221588
  $fShowScope_$cshowList ::
    [JackParser.Lexer.Scope] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ ls :: [JackParser.Lexer.Scope] s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ JackParser.Lexer.Scope
                   (JackParser.Lexer.$fShowScope_$cshowsPrec GHC.Show.shows18)
                   ls
                   s) -}
f640582c3ce4c1fa29e06a362c221588
  $fShowScope_$cshowsPrec ::
    GHC.Types.Int -> JackParser.Lexer.Scope -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: JackParser.Lexer.Scope
                   w2 :: GHC.Base.String ->
                 JackParser.Lexer.$w$cshowsPrec3 w1 w2) -}
e06ca1c44b5ca55a52b49f13e3f094fe
  $fShowUAOp :: GHC.Show.Show JackParser.Lexer.UAOp
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.UAOp
                  JackParser.Lexer.$fShowUAOp_$s$dmshowsPrec
                  JackParser.Lexer.$fShowUAOp_$cshow
                  JackParser.Lexer.$fShowUAOp_$cshowList -}
e06ca1c44b5ca55a52b49f13e3f094fe
  $fShowUAOp1 ::
    JackParser.Lexer.UAOp -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ x :: JackParser.Lexer.UAOp
                   s :: GHC.Base.String[OneShot] ->
                 case x of wild { JackParser.Lexer.Neg ->
                 GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowUAOp2 s }) -}
c21948fdb230f53c3521d65d9b7e7a7a
  $fShowUAOp2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "neg"#) -}
e06ca1c44b5ca55a52b49f13e3f094fe
  $fShowUAOp_$cshow :: JackParser.Lexer.UAOp -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: JackParser.Lexer.UAOp ->
                 case ds of wild { JackParser.Lexer.Neg ->
                 JackParser.Lexer.$fShowUAOp2 }) -}
e06ca1c44b5ca55a52b49f13e3f094fe
  $fShowUAOp_$cshowList :: [JackParser.Lexer.UAOp] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ ls :: [JackParser.Lexer.UAOp] s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ JackParser.Lexer.UAOp
                   JackParser.Lexer.$fShowUAOp1
                   ls
                   s) -}
e06ca1c44b5ca55a52b49f13e3f094fe
  $fShowUAOp_$s$dmshowsPrec ::
    GHC.Types.Int -> JackParser.Lexer.UAOp -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*H><L,1*U>,
     Unfolding: InlineRule (-1, True, False)
                (\ ds :: GHC.Types.Int
                   x :: JackParser.Lexer.UAOp
                   s :: GHC.Base.String ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (JackParser.Lexer.$fShowUAOp_$cshow x))
                   s) -}
5b4e4b914326506c05e696f27d3c09f5
  $fShowUBOp :: GHC.Show.Show JackParser.Lexer.UBOp
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.UBOp
                  JackParser.Lexer.$fShowUBOp_$s$dmshowsPrec
                  JackParser.Lexer.$fShowUBOp_$cshow
                  JackParser.Lexer.$fShowUBOp_$cshowList -}
5b4e4b914326506c05e696f27d3c09f5
  $fShowUBOp1 ::
    JackParser.Lexer.UBOp -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ x :: JackParser.Lexer.UBOp
                   s :: GHC.Base.String[OneShot] ->
                 case x of wild { JackParser.Lexer.Not ->
                 GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowUBOp2 s }) -}
6394c5d20d8d78e964581bf483e6fccf
  $fShowUBOp2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "not"#) -}
5b4e4b914326506c05e696f27d3c09f5
  $fShowUBOp_$cshow :: JackParser.Lexer.UBOp -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: JackParser.Lexer.UBOp ->
                 case ds of wild { JackParser.Lexer.Not ->
                 JackParser.Lexer.$fShowUBOp2 }) -}
5b4e4b914326506c05e696f27d3c09f5
  $fShowUBOp_$cshowList :: [JackParser.Lexer.UBOp] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ ls :: [JackParser.Lexer.UBOp] s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ JackParser.Lexer.UBOp
                   JackParser.Lexer.$fShowUBOp1
                   ls
                   s) -}
5b4e4b914326506c05e696f27d3c09f5
  $fShowUBOp_$s$dmshowsPrec ::
    GHC.Types.Int -> JackParser.Lexer.UBOp -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*H><L,1*U>,
     Unfolding: InlineRule (-1, True, False)
                (\ ds :: GHC.Types.Int
                   x :: JackParser.Lexer.UBOp
                   s :: GHC.Base.String ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (JackParser.Lexer.$fShowUBOp_$cshow x))
                   s) -}
be410ceafbd8c6f0e883a2c57696dc8d
  $fShowUOp :: GHC.Show.Show JackParser.Lexer.UOp
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ JackParser.Lexer.UOp
                  JackParser.Lexer.$fShowUOp_$s$dmshowsPrec
                  JackParser.Lexer.$fShowUOp_$cshow
                  JackParser.Lexer.$fShowUOp_$cshowList -}
be410ceafbd8c6f0e883a2c57696dc8d
  $fShowUOp1 ::
    JackParser.Lexer.UOp -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ x :: JackParser.Lexer.UOp
                   s :: GHC.Base.String[OneShot] ->
                 case x of wild {
                   JackParser.Lexer.UA x1
                   -> case x1 of wild1 { JackParser.Lexer.Neg ->
                      GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowUAOp2 s }
                   JackParser.Lexer.UB x1
                   -> case x1 of wild1 { JackParser.Lexer.Not ->
                      GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowUBOp2 s } }) -}
be410ceafbd8c6f0e883a2c57696dc8d
  $fShowUOp_$cshow :: JackParser.Lexer.UOp -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: JackParser.Lexer.UOp ->
                 case ds of wild {
                   JackParser.Lexer.UA x
                   -> case x of wild1 { JackParser.Lexer.Neg ->
                      JackParser.Lexer.$fShowUAOp2 }
                   JackParser.Lexer.UB x
                   -> case x of wild1 { JackParser.Lexer.Not ->
                      JackParser.Lexer.$fShowUBOp2 } }) -}
be410ceafbd8c6f0e883a2c57696dc8d
  $fShowUOp_$cshowList :: [JackParser.Lexer.UOp] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ ls :: [JackParser.Lexer.UOp] s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ JackParser.Lexer.UOp
                   JackParser.Lexer.$fShowUOp1
                   ls
                   s) -}
be410ceafbd8c6f0e883a2c57696dc8d
  $fShowUOp_$s$dmshowsPrec ::
    GHC.Types.Int -> JackParser.Lexer.UOp -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (-1, True, False)
                (\ ds :: GHC.Types.Int
                   x :: JackParser.Lexer.UOp
                   s :: GHC.Base.String ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (JackParser.Lexer.$fShowUOp_$cshow x))
                   s) -}
46f3b98594f85114bb4829f629db1420
  $sread :: GHC.Base.String -> JackParser.Lexer.IntLit
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Base.String ->
                 case Text.Read.readEither
                        @ JackParser.Lexer.IntLit
                        GHC.Read.$fReadInt
                        s of wild {
                   Data.Either.Left x -> GHC.Err.error @ JackParser.Lexer.IntLit x
                   Data.Either.Right y -> y }) -}
4ceb7307f8ee08c3bdebb363f9dd3cb6
  $w$cshowsPrec ::
    JackParser.Lexer.BAOp -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: JackParser.Lexer.BAOp w1 :: GHC.Base.String ->
                 case w of wild {
                   JackParser.Lexer.Add
                   -> GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowBAOp4 w1
                   JackParser.Lexer.Sub
                   -> GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowBAOp3 w1
                   JackParser.Lexer.Mult
                   -> GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowBAOp2 w1
                   JackParser.Lexer.Div
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        JackParser.Lexer.$fShowBAOp1
                        w1 }) -}
fb7036306be5bcfd6aee8801cbc91af6
  $w$cshowsPrec1 ::
    JackParser.Lexer.FunType -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: JackParser.Lexer.FunType
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   JackParser.Lexer.Function
                   -> GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowFunType3 w1
                   JackParser.Lexer.Method
                   -> GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowFunType2 w1
                   JackParser.Lexer.Constructor
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        JackParser.Lexer.$fShowFunType1
                        w1 }) -}
7b5674010925f9dcd30e2dcad387229f
  $w$cshowsPrec2 ::
    JackParser.Lexer.RBOp -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: JackParser.Lexer.RBOp w1 :: GHC.Base.String ->
                 case w of wild {
                   JackParser.Lexer.Eq
                   -> GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowBOp4 w1
                   JackParser.Lexer.Lt
                   -> GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowBOp3 w1
                   JackParser.Lexer.Gt
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        JackParser.Lexer.$fShowBOp2
                        w1 }) -}
f640582c3ce4c1fa29e06a362c221588
  $w$cshowsPrec3 ::
    JackParser.Lexer.Scope -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: JackParser.Lexer.Scope w1 :: GHC.Base.String ->
                 case w of wild {
                   JackParser.Lexer.Field
                   -> GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowScope4 w1
                   JackParser.Lexer.Static
                   -> GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowScope3 w1
                   JackParser.Lexer.Local
                   -> GHC.Base.++ @ GHC.Types.Char JackParser.Lexer.$fShowScope2 w1
                   JackParser.Lexer.Argument
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        JackParser.Lexer.$fShowScope1
                        w1 }) -}
22b196a9da59a4c298069ccfa142f461
  $wa ::
    GHC.Base.String
    -> Text.Parsec.Pos.SourceName
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 7,
     Strictness: <L,U><L,U><L,U><L,U><S,U><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0],
     Unfolding: (\ @ u
                   @ b
                   ww :: GHC.Base.String
                   ww1 :: Text.Parsec.Pos.SourceName
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: u
                   w :: GHC.Types.Char
                        -> Text.Parsec.Prim.State GHC.Base.String u
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b
                   w1 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isAlphaNum
                   @ b
                   ww
                   ww1
                   ww2
                   ww3
                   ww4
                   w
                   (\ err :: Text.Parsec.Error.ParseError ->
                    let {
                      err1 :: Text.Parsec.Error.ParseError
                      = case err of ww5 { Text.Parsec.Error.ParseError ww6 ww7 ->
                        case Text.Parsec.Prim.$wsetExpectErrors
                               ww6
                               ww7
                               JackParser.Lexer.languageDef_msgs of ww8 { (#,#) ww9 ww10 ->
                        Text.Parsec.Error.ParseError ww9 ww10 } }
                    } in
                    Text.Parsec.Char.$wa
                      @ GHC.Base.String
                      @ u
                      @ Data.Functor.Identity.Identity
                      (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                      JackParser.Lexer.languageDef62
                      @ b
                      ww
                      ww1
                      ww2
                      ww3
                      ww4
                      w
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       w1 (Text.Parsec.Error.mergeError err1 err')))) -}
13d2a37cb45854652a0c4d4fa33df8fb
  $wa1 ::
    GHC.Base.String
    -> Text.Parsec.Pos.SourceName
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 9,
     Strictness: <L,U><L,U><L,U><L,U><S,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0],
     Unfolding: (\ @ u
                   @ b
                   ww :: GHC.Base.String
                   ww1 :: Text.Parsec.Pos.SourceName
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: u
                   w :: GHC.Types.Char
                        -> Text.Parsec.Prim.State GHC.Base.String u
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b
                   w1 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w2 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w3 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b ->
                 let {
                   ww5 :: Text.Parsec.Pos.SourcePos
                   = Text.Parsec.Pos.SourcePos ww1 ww2 ww3
                 } in
                 let {
                   ww6 :: Text.Parsec.Prim.State GHC.Base.String u
                   = Text.Parsec.Prim.State @ GHC.Base.String @ u ww ww5 ww4
                 } in
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isAlpha
                   @ b
                   ww
                   ww1
                   ww2
                   ww3
                   ww4
                   w
                   (\ err :: Text.Parsec.Error.ParseError ->
                    let {
                      err1 :: Text.Parsec.Error.ParseError
                      = case err of ww7 { Text.Parsec.Error.ParseError ww8 ww9 ->
                        case Text.Parsec.Prim.$wsetExpectErrors
                               ww8
                               ww9
                               JackParser.Lexer.languageDef_msgs1 of ww10 { (#,#) ww11 ww12 ->
                        Text.Parsec.Error.ParseError ww11 ww12 } }
                    } in
                    (JackParser.Lexer.languageDef65 @ u)
                      `cast`
                    (Text.Parsec.Prim.NTCo:ParsecT[0]
                         <GHC.Base.String>_R
                         <u>_R
                         <Data.Functor.Identity.Identity>_R
                         <GHC.Types.Char>_R)
                      @ b
                      ww6
                      w
                      w1
                      (\ y :: GHC.Types.Char
                         s' :: Text.Parsec.Prim.State GHC.Base.String u
                         err' :: Text.Parsec.Error.ParseError ->
                       w2 y s' (Text.Parsec.Error.mergeError err1 err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       w3 (Text.Parsec.Error.mergeError err1 err')))) -}
4ceb7307f8ee08c3bdebb363f9dd3cb6
  data BAOp = Add | Sub | Mult | Div
    Promotable
466d0d1969976101807d66ed5c06e1dc
  data BBOp = And | Or
    Promotable
53109870470fa3811ff03652ee2530bf
  data BOp
    = BA JackParser.Lexer.BAOp
    | BB JackParser.Lexer.BBOp
    | RB JackParser.Lexer.RBOp
    Promotable
5585d32fe30beb50bffa4cc11aa621ed
  data Boolean = T | F
    Promotable
db754a485a7967eb2e0c962fe3283214
  type Comment = ()
fb7036306be5bcfd6aee8801cbc91af6
  data FunType = Function | Method | Constructor
    Promotable
e84140e2b16d3f29743eb3d453988348
  type Identifier = GHC.Base.String
4e1e3e9e3b22f5b08564606e83c88f94
  type IntLit = GHC.Types.Int
7b5674010925f9dcd30e2dcad387229f
  data RBOp = Eq | Lt | Gt
    Promotable
f640582c3ce4c1fa29e06a362c221588
  data Scope = Field | Static | Local | Argument
    Promotable
a8e3fa61288257c55d7fe7259cb3caa5
  type TType = GHC.Base.String
e06ca1c44b5ca55a52b49f13e3f094fe
  data UAOp = Neg
    Promotable
5b4e4b914326506c05e696f27d3c09f5
  data UBOp = Not
    Promotable
be410ceafbd8c6f0e883a2c57696dc8d
  data UOp = UA JackParser.Lexer.UAOp | UB JackParser.Lexer.UBOp
    Promotable
81d0080ec5d744223f7c92c94d651d26
  type VarType = GHC.Base.String
20327182f1b1b56a8fc33170d1dfa33e
  bAOp :: Text.Parsec.String.Parser JackParser.Lexer.BAOp
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                JackParser.Lexer.bAOp1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <JackParser.Lexer.BAOp>_R)) -}
cb346ae9d5c22c693d120ee946782f35
  bAOp1 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (JackParser.Lexer.BAOp
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (JackParser.Lexer.BAOp
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   eta1 :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta2 :: JackParser.Lexer.BAOp
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: JackParser.Lexer.BAOp
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Combinator.choice3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ JackParser.Lexer.BAOp
                   JackParser.Lexer.bAOp2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
4818961465abf9bbcb09afe231887448
  bAOp10 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.BAOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.BAOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.BAOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.BAOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.bAOp_m4
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Add
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Add
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
e7977b7970007f8a78b6af9b5a0cba98
  bAOp2 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.BAOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.BAOp)
                   JackParser.Lexer.bAOp10
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.BAOp>_R))
                   JackParser.Lexer.bAOp3) -}
1f417186dbe1f0502e881537230ad861
  bAOp3 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.BAOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.BAOp)
                   JackParser.Lexer.bAOp9
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.BAOp>_R))
                   JackParser.Lexer.bAOp4) -}
4959c5eee4c0e34a506da4c8c1a7fde1
  bAOp4 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.BAOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.BAOp)
                   JackParser.Lexer.bAOp8
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.BAOp>_R))
                   JackParser.Lexer.bAOp5) -}
57c6f7cc4b962a551590a6ac14e25959
  bAOp5 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.BAOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.BAOp)
                   JackParser.Lexer.bAOp6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.BAOp>_R))
                   (GHC.Types.[]
                      @ (Text.Parsec.Prim.ParsecT
                           GHC.Base.String
                           ()
                           Data.Functor.Identity.Identity
                           JackParser.Lexer.BAOp))) -}
a4a568809ce08210bf09dca312b020ae
  bAOp6 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.BAOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.BAOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.BAOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.BAOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.bAOp_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Div
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Div
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
0530d12d2669cf85348e8f660171614f
  bAOp7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "/"#) -}
c7cc75d34ec708089043d2b584fc8ebb
  bAOp8 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.BAOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.BAOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.BAOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.BAOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.bAOp_m2
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Mult
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Mult
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
3e2b8a0068d2bf687bace02e952da248
  bAOp9 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.BAOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.BAOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.BAOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.BAOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.bAOp_m3
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Sub
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Sub
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
120b770cf9405f854c54bcc0cf6fda60
  bAOp_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds4 JackParser.Lexer.bAOp7 }) -}
13118a272e680d5d213c579d406b957f
  bAOp_m2 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds4 JackParser.Lexer.languageDef17 }) -}
856e7e0c5c31597f58a054d1acbfb2b7
  bAOp_m3 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds4 JackParser.Lexer.languageDef18 }) -}
2b0c0e331eb80ded2b0a6a3e00fdf8df
  bAOp_m4 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds4 JackParser.Lexer.languageDef19 }) -}
73bbbb5b3f299ddfc2d19c490dbb1715
  bBOp :: Text.Parsec.String.Parser JackParser.Lexer.BBOp
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                JackParser.Lexer.bBOp1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <JackParser.Lexer.BBOp>_R)) -}
b69fc15bd942daaa3bfd04f560a8abea
  bBOp1 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (JackParser.Lexer.BBOp
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (JackParser.Lexer.BBOp
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   eta1 :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta2 :: JackParser.Lexer.BBOp
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: JackParser.Lexer.BBOp
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Combinator.choice3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ JackParser.Lexer.BBOp
                   JackParser.Lexer.bBOp2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
def7aa88af95031814772571294fa70a
  bBOp2 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.BBOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.BBOp)
                   JackParser.Lexer.bBOp5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.BBOp>_R))
                   JackParser.Lexer.bBOp3) -}
ff816f0de0e4772ed636ba2f05caa8f7
  bBOp3 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.BBOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.BBOp)
                   JackParser.Lexer.bBOp4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.BBOp>_R))
                   (GHC.Types.[]
                      @ (Text.Parsec.Prim.ParsecT
                           GHC.Base.String
                           ()
                           Data.Functor.Identity.Identity
                           JackParser.Lexer.BBOp))) -}
752f741b194874d10ea3c4283cba70c7
  bBOp4 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.BBOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.BBOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.BBOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.BBOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.bBOp_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Or
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Or
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
39862357794872697411b0de59b3be34
  bBOp5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.BBOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.BBOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.BBOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.BBOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.bBOp_m2
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.And
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.And
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
e22405de303d1ee85cf64d365d72db89
  bBOp_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef15 }) -}
ba50a9db0d017f6527ab3c273999036a
  bBOp_m2 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef16 }) -}
2471a47628e77144a53909ecb7761e8c
  blockC :: Text.Parsec.String.Parser JackParser.Lexer.Comment
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds15
                   @ ()
                   JackParser.Lexer.blockC1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R)) }) -}
59180e31f34c8d60ecac1e3ab02c4ff0
  blockC1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: ()
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: ()
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Char.string1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   JackParser.Lexer.languageDef69
                   @ b1
                   eta
                   (\ x :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    JackParser.Lexer.blockC2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: ()
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: GHC.Base.String[OneShot]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    JackParser.Lexer.blockC2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: ()
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
659db48110a683a5fc47a5340dd6eb9e
  blockC2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: ()
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1[OneShot]
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1[OneShot]
                   eta3 :: ()
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1[OneShot]
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1[OneShot] ->
                 Text.Parsec.Combinator.$wa7
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   @ GHC.Base.String
                   @ GHC.Types.Char
                   JackParser.Lexer.blockC4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   JackParser.Lexer.blockC3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.String>_R))
                   @ b1
                   eta
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    eta1
                      GHC.Tuple.()
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    eta3
                      GHC.Tuple.()
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
163d9081a6f517d27ce07a36af63a5be
  blockC3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (GHC.Base.String
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Base.String
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,1*C1(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: GHC.Base.String
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   ds :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   eok :: GHC.Base.String
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Char.string1
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   JackParser.Lexer.languageDef68
                   @ b
                   s1
                   cok
                   eerr
                   eok
                   eerr) -}
77a631208d51e11a6d05d52bc1ebe174
  blockC4 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LSS),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta1 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 case eta of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Text.Parsec.Char.anyChar2
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   eta1
                   eta4 } }) -}
fe01ffa79782b97f884f05cecddab62e
  boolean :: Text.Parsec.String.Parser JackParser.Lexer.Boolean
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                JackParser.Lexer.boolean1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <JackParser.Lexer.Boolean>_R)) -}
69268bf2d4adf7fd3f97c8aab5c3687e
  boolean1 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (JackParser.Lexer.Boolean
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (JackParser.Lexer.Boolean
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   eta1 :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta2 :: JackParser.Lexer.Boolean
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: JackParser.Lexer.Boolean
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Combinator.choice3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ JackParser.Lexer.Boolean
                   JackParser.Lexer.boolean2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
0f8eca77c0695c1022a9b7bd4081dec1
  boolean2 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.Boolean]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.Boolean)
                   JackParser.Lexer.boolean5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.Boolean>_R))
                   JackParser.Lexer.boolean3) -}
9f6ebe85b926596b45023f954734bff6
  boolean3 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.Boolean]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.Boolean)
                   JackParser.Lexer.boolean4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.Boolean>_R))
                   (GHC.Types.[]
                      @ (Text.Parsec.Prim.ParsecT
                           GHC.Base.String
                           ()
                           Data.Functor.Identity.Identity
                           JackParser.Lexer.Boolean))) -}
88840bf3e8a0a10cb90d68ff9f04b285
  boolean4 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.Boolean
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.Boolean
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.Boolean
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.Boolean
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.boolean_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.F
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.F
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
7e5002858006c955aa48869e9a6a82cc
  boolean5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.Boolean
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.Boolean
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.Boolean
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.Boolean
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.boolean_m2
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.T
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.T
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
829de41bb6b3e0f83404bcf1d3d52b48
  boolean_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef46 }) -}
a1d6206d20a4dedc153e24c2218cf66f
  boolean_m2 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef47 }) -}
2e0e4c1813f93d3c94e941679f05b2ca
  braces ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity a
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String u Data.Functor.Identity.Identity a
  {- Unfolding: (\ @ u @ a8 ->
                 case JackParser.Lexer.lexer
                        @ u of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds18 @ a8 }) -}
8bda5df8d9bf6e33e0e85a1e29122415
  brackets ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity a
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String u Data.Functor.Identity.Identity a
  {- Unfolding: (\ @ u @ a8 ->
                 case JackParser.Lexer.lexer
                        @ u of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds20 @ a8 }) -}
9b67c7d7ca662999bc371b2716d2d2ec
  cmt ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char]
      ()
      Data.Functor.Identity.Identity
      JackParser.Lexer.Comment
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                JackParser.Lexer.cmt1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <JackParser.Lexer.Comment>_R)) -}
67fde138846fa36f3e887b1e88d0b9f1
  cmt1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.Comment
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (JackParser.Lexer.Comment
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,C(U)>,
     Unfolding: (\ @ b
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: JackParser.Lexer.Comment
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eok :: JackParser.Lexer.Comment
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 let {
                   eerr1 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b
                     {- Arity: 1, Strictness: <L,U(U(U,U,U),U)> -}
                   = \ err :: Text.Parsec.Error.ParseError ->
                     JackParser.Lexer.lineC
                       `cast`
                     (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <JackParser.Lexer.Comment>_R)
                       @ b
                       s1
                       cok
                       cerr
                       (\ y :: JackParser.Lexer.Comment
                          s' :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                          err' :: Text.Parsec.Error.ParseError ->
                        eok y s' (Text.Parsec.Error.mergeError err err'))
                       (\ err' :: Text.Parsec.Error.ParseError ->
                        eerr (Text.Parsec.Error.mergeError err err'))
                 } in
                 JackParser.Lexer.blockC
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <JackParser.Lexer.Comment>_R)
                   @ b
                   s1
                   cok
                   eerr1
                   eok
                   eerr1) -}
0475bc9a0bed02d57e1f743874491e35
  comma ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity GHC.Base.String
  {- Unfolding: (\ @ u ->
                 case JackParser.Lexer.lexer
                        @ u of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds23 }) -}
570449c7495e301042e96f45e131613e
  commaSep ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity a
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String u Data.Functor.Identity.Identity [a]
  {- Unfolding: (\ @ u @ a8 ->
                 case JackParser.Lexer.lexer
                        @ u of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds28 @ a8 }) -}
785415576e1c9ef7eae373f3cffcd621
  funType :: Text.Parsec.String.Parser JackParser.Lexer.FunType
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                JackParser.Lexer.funType1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <JackParser.Lexer.FunType>_R)) -}
35717a7996ab3f8114c9ffbad87ba521
  funType1 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (JackParser.Lexer.FunType
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (JackParser.Lexer.FunType
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   eta1 :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta2 :: JackParser.Lexer.FunType
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: JackParser.Lexer.FunType
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Combinator.choice3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ JackParser.Lexer.FunType
                   JackParser.Lexer.funType2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
9d8cda5bf4f08ee6be4aa18e6def445a
  funType2 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.FunType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.FunType)
                   JackParser.Lexer.funType7
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.FunType>_R))
                   JackParser.Lexer.funType3) -}
e7d5aeb5d9d9f5e754c1a8ab1fe05301
  funType3 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.FunType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.FunType)
                   JackParser.Lexer.funType6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.FunType>_R))
                   JackParser.Lexer.funType4) -}
4c11188d993812a74384538c340370a2
  funType4 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.FunType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.FunType)
                   JackParser.Lexer.funType5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.FunType>_R))
                   (GHC.Types.[]
                      @ (Text.Parsec.Prim.ParsecT
                           GHC.Base.String
                           ()
                           Data.Functor.Identity.Identity
                           JackParser.Lexer.FunType))) -}
90fff25eff21bc51e1c703e3d9b6c281
  funType5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.FunType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.FunType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.FunType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.FunType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.funType_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Method
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Method
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
010437246a6dca7f2d4bb62d202a21f9
  funType6 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.FunType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.FunType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.FunType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.FunType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.funType_m2
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Function
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Function
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
a0dbf759a5e7a3ac74b163ed0f7a2edf
  funType7 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.FunType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.FunType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.FunType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.FunType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.funType_m3
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Constructor
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Constructor
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
8d3bca1a5f73c104b9237e7a6396e529
  funType_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef51 }) -}
a9f880490617dc90f7b543fec18e992d
  funType_m2 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef50 }) -}
2a9696cf1789a85b4bfeb3cd80e31c7f
  funType_m3 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef52 }) -}
c1ecf48790375f10a113b99db0cea7fc
  identifier ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity GHC.Base.String
  {- Unfolding: (\ @ u ->
                 case JackParser.Lexer.lexer
                        @ u of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds1 }) -}
ff9b871025c5342250cf3ed0bf5450b0
  integer :: Text.Parsec.String.Parser JackParser.Lexer.IntLit
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds15
                   @ JackParser.Lexer.IntLit
                   JackParser.Lexer.integer1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.IntLit>_R)) }) -}
22a0446ee3511881e60ec1c6469ed82c
  integer1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.IntLit
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.IntLit
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.IntLit
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.IntLit
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Combinator.many3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   JackParser.Lexer.integer2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   @ b1
                   eta
                   (\ x :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    eta1
                      (JackParser.Lexer.$sread x)
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    eta3
                      (JackParser.Lexer.$sread x)
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
d6391ed1cb953ac0410d8da957d7e12b
  integer2 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta1 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b[OneShot]
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b[OneShot]
                   eta3 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b[OneShot]
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b[OneShot] ->
                 Text.Parsec.Prim.<?>2
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   JackParser.Lexer.integer4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   JackParser.Lexer.integer3
                   @ b
                   eta
                   eta1
                   eta2
                   eta3
                   eta4) -}
eeff81a99cca51e93d079687f48f7389
  integer3 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.digit2
                   (GHC.Types.[] @ GHC.Base.String)) -}
de6b3407f674de55bbc40d81971d1e7b
  integer4 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   w2 :: Text.Parsec.Prim.State GHC.Base.String ()[OneShot]
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w5 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w6 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot] ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isDigit
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
c85dcc8cc342a533ba1948120b00bafc
  languageDef ::
    Text.Parsec.Token.GenLanguageDef
      GHC.Base.String u Data.Functor.Identity.Identity
  {- Unfolding: (\ @ u ->
                 Text.Parsec.Token.LanguageDef
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   JackParser.Lexer.languageDef69
                   JackParser.Lexer.languageDef68
                   JackParser.Lexer.languageDef67
                   GHC.Types.True
                   (JackParser.Lexer.languageDef64 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (JackParser.Lexer.languageDef61 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (Text.Parsec.Language.emptyDef1 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (Text.Parsec.Language.emptyDef1 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   JackParser.Lexer.languageDef20
                   JackParser.Lexer.languageDef1
                   GHC.Types.True) -}
d692b3adc064fb25be18becc0cd2f67b
  languageDef1 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef19
                   JackParser.Lexer.languageDef2) -}
143dbb870cc1a2a350976cfdacdee037
  languageDef10 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef11
                   (GHC.Types.[] @ GHC.Base.String)) -}
2188a26779326469b0efc2e939c6cf3e
  languageDef11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "="#) -}
5036208a8256d834a88631230b92cd19
  languageDef12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ">"#) -}
3b8cebeb1688fb62fec0757f800d0df6
  languageDef13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "<"#) -}
bbc94aebef09c4d932a60d2fdb4fb2f5
  languageDef14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "~"#) -}
ae9cd0b51651308225590e90fef02def
  languageDef15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "|"#) -}
65072f78dbec0c52520d94e3b657dd70
  languageDef16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "&"#) -}
62f47806fedffa9da4311613a63fd523
  languageDef17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "*"#) -}
eb50dac6cec7679d335b076748a44f78
  languageDef18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "-"#) -}
1b205447d488cabaf2553f4834cafda4
  languageDef19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "+"#) -}
4234f9bde09252249957a15f35f64520
  languageDef2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef18
                   JackParser.Lexer.languageDef3) -}
e05d8a0e495cdf5c2ae87297c8a0846a
  languageDef20 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef60
                   JackParser.Lexer.languageDef21) -}
24322e483e6b0fc8ce5ac123a7109290
  languageDef21 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef59
                   JackParser.Lexer.languageDef22) -}
d5763c4b3ff4488c2fb1ed5fc7129468
  languageDef22 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef58
                   JackParser.Lexer.languageDef23) -}
7c4fd4387cd839c8c1de6c9d8abcafc9
  languageDef23 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef57
                   JackParser.Lexer.languageDef24) -}
b422d62ec07c24d2e0c6a6f6717f3f5d
  languageDef24 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef56
                   JackParser.Lexer.languageDef25) -}
45745bd0f6d1ddbaf9c5dfc7c36c041d
  languageDef25 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef55
                   JackParser.Lexer.languageDef26) -}
c5a45ac22a9c05971dde17073cef9770
  languageDef26 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef54
                   JackParser.Lexer.languageDef27) -}
e53448888205551ca0166388773bbfab
  languageDef27 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef53
                   JackParser.Lexer.languageDef28) -}
09635811c8ee2e82f3b8770e5d4c05c3
  languageDef28 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef52
                   JackParser.Lexer.languageDef29) -}
62111d2cb89198ad18a55cfe35e45a8e
  languageDef29 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef51
                   JackParser.Lexer.languageDef30) -}
4ea58c97d6b477ad7c1f30406b656d86
  languageDef3 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef17
                   JackParser.Lexer.languageDef4) -}
b569f321236665422fe0e54ff5f9c918
  languageDef30 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef50
                   JackParser.Lexer.languageDef31) -}
1534cdc9010eebcc3f71f4f8cba57c1e
  languageDef31 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef49
                   JackParser.Lexer.languageDef32) -}
c8727f90d5887a111fb67c787aed5fb8
  languageDef32 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.$fShowScope3
                   JackParser.Lexer.languageDef33) -}
3ee9ee6807211e7b86fae0f30abb4a2a
  languageDef33 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef48
                   JackParser.Lexer.languageDef34) -}
196b71393bc10fe897ddedfae2f0b254
  languageDef34 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef47
                   JackParser.Lexer.languageDef35) -}
f1a98b426f7fabb47a7ddfaee1ae4b03
  languageDef35 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef46
                   JackParser.Lexer.languageDef36) -}
d746d00108b066a0779482e13b12f9e6
  languageDef36 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef45
                   JackParser.Lexer.languageDef37) -}
c9d1f6a71d7b1acd55a21f638138446e
  languageDef37 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef44
                   JackParser.Lexer.languageDef38) -}
b2e25f90bafda579bc37afb0641607a3
  languageDef38 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef43
                   JackParser.Lexer.languageDef39) -}
c3fb245df504c79ef705cb991194b612
  languageDef39 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef42
                   JackParser.Lexer.languageDef40) -}
4300d02564317a62a2a280f5754edb03
  languageDef4 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.bAOp7
                   JackParser.Lexer.languageDef5) -}
4dee5aa2f5796b46c1de184fe8a2d47c
  languageDef40 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef41
                   (GHC.Types.[] @ GHC.Base.String)) -}
e0374892539ac2949e2605db9a990387
  languageDef41 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "void"#) -}
40c0fe6b8052f2d62a8eef3b071ee034
  languageDef42 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "boolean"#) -}
23c47a7fb8a948332ebf7b7e24fa3b08
  languageDef43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "int"#) -}
1917aacea5c514549cb46fcfa44f529d
  languageDef44 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "char"#) -}
3dce807807a913803fc2682a93dd12b4
  languageDef45 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "null"#) -}
faec37bb354640d1a41c19ac76ab05a6
  languageDef46 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "false"#) -}
940f0c1f77c2cbba213eef7c2c228d17
  languageDef47 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "true"#) -}
35d690043af220810374133d5cca1e8b
  languageDef48 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "field"#) -}
5511fbb8706bd8d7da283dee0616d8a9
  languageDef49 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "var"#) -}
26602b65b5631dc3dfc279f4beecc7d6
  languageDef5 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef16
                   JackParser.Lexer.languageDef6) -}
4d3b3dc82105947bb7844c046f0c3fa4
  languageDef50 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "function"#) -}
2a3435e0c3cdf587ded0e54b818d822e
  languageDef51 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "method"#) -}
fb19739373885a83f8a8cb9352a71bd0
  languageDef52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "constructor"#) -}
88af45705051f9e51249c4eaa94e5d90
  languageDef53 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "class"#) -}
8bfaac3d9fe3204d249e60e4eda5ae65
  languageDef54 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Return"#) -}
e693f2b7f5d7fb40e274e0ab620760c0
  languageDef55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "return"#) -}
bae06d4a30b425c02134efca974109c5
  languageDef56 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "do"#) -}
ea522d0d91f82491c00c93dee649bc0e
  languageDef57 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "let"#) -}
5b328d8a512ea13dd8ff5c0b6a817f6c
  languageDef58 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "else"#) -}
bc58374e4140ac8297e131b8de3d40f3
  languageDef59 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "then"#) -}
2792ac82bf25766d80fe0ad182be10ee
  languageDef6 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef15
                   JackParser.Lexer.languageDef7) -}
26780d769b7bf87fb5d7f0f3c6b9f5ba
  languageDef60 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "if"#) -}
cb8f85a70287bb29ad4509c5e3fd3edc
  languageDef61 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LSS),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ u
                   @ b
                   w :: Text.Parsec.Prim.State GHC.Base.String u
                   w1 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 JackParser.Lexer.$wa @ u @ b ww1 ww5 ww6 ww7 ww3 w1 w4 } }) -}
9467090d53ef08b05368cbf65aacd4aa
  languageDef62 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1,
     Unfolding: (\ c :: GHC.Types.Char ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   c
                   JackParser.Lexer.languageDef63) -}
ed9cbc7f66e42e9085cd94736def3ecc
  languageDef63 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "._"#) -}
80e57c06e63394ee49cf2fc32b1b3396
  languageDef64 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LSS),1*U(U,U(U,U,U),U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ u
                   @ b
                   w :: Text.Parsec.Prim.State GHC.Base.String u
                   w1 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 JackParser.Lexer.$wa1
                   @ u
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w1
                   w2
                   w3
                   w4 } }) -}
30ff6a8c9356433b90905b154167fdc9
  languageDef65 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity GHC.Types.Char
  {- Unfolding: (\ @ u ->
                 Text.Parsec.Char.char
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   JackParser.Lexer.languageDef66) -}
556c2ceee8883718d15451bde9e338d7
  languageDef66 :: GHC.Types.Char
  {- HasNoCafRefs, Unfolding: (GHC.Types.C# '_') -}
805fc91bf331c6dfbf2e121cec45e9ad
  languageDef67 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "//"#) -}
68b2b92c57794346cd3c0bd1387b808a
  languageDef68 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "*/"#) -}
c7a8f87ee9b80396fb06446512f81450
  languageDef69 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "/**"#) -}
9a3f9208e80f3199942c95184c67b698
  languageDef7 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef14
                   JackParser.Lexer.languageDef8) -}
22a3d08dff586ab0dbc13fa9c92b5ac5
  languageDef8 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef13
                   JackParser.Lexer.languageDef9) -}
354bce9de730a49d07cc7c3f64c24dd0
  languageDef9 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   JackParser.Lexer.languageDef12
                   JackParser.Lexer.languageDef10) -}
0b888d8b979f38f16481911857772f6f
  languageDef_msgs :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.alphaNum2
                   (GHC.Types.[] @ GHC.Base.String)) -}
19bd32d64913d98b1d7907b4e3b98032
  languageDef_msgs1 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.letter2
                   (GHC.Types.[] @ GHC.Base.String)) -}
f045eb8e9ad5ce8fc8cc7736032857b8
  lexeme ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity a
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String u Data.Functor.Identity.Identity a
  {- Unfolding: (\ @ u @ a8 ->
                 case JackParser.Lexer.lexer
                        @ u of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds15 @ a8 }) -}
5a23a3ca30dc539edfc372ca73e5f46f
  lexer ::
    Text.Parsec.Token.GenTokenParser
      GHC.Base.String u Data.Functor.Identity.Identity
  {- Unfolding: (\ @ u ->
                 Text.Parsec.Token.makeTokenParser
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   (JackParser.Lexer.languageDef @ u)) -}
9adcc822c4babefb02fb9adcd17ebb03
  lineC :: Text.Parsec.String.Parser JackParser.Lexer.Comment
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds15
                   @ ()
                   JackParser.Lexer.lineC1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R)) }) -}
2ed669365a0e318b90655d6a558fd34a
  lineC1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: ()
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: ()
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Char.string1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   JackParser.Lexer.languageDef67
                   @ b1
                   eta
                   (\ x :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    JackParser.Lexer.lineC2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: ()
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: GHC.Base.String[OneShot]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    JackParser.Lexer.lineC2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: ()
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
d1b6874437d71fcba0ec62adc1c20d5f
  lineC2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: ()
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1[OneShot]
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1[OneShot]
                   eta3 :: ()
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1[OneShot]
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1[OneShot] ->
                 Text.Parsec.Combinator.$wa7
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   @ GHC.Types.Char
                   @ GHC.Types.Char
                   JackParser.Lexer.blockC4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   JackParser.Lexer.lineC3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   @ b1
                   eta
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    eta1
                      GHC.Tuple.()
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    eta3
                      GHC.Tuple.()
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
f364a2d8b083a37fdf11fac785a13be9
  lineC3 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LSS),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   w :: Text.Parsec.Prim.State GHC.Base.String ()
                   w1 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot] ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   JackParser.Lexer.lineC4
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w1
                   w4 } }) -}
184795b399ea728cabf242a86211e5df
  lineC4 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1,
     Unfolding: (\ c :: GHC.Types.Char ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   c
                   JackParser.Lexer.lineC_cs) -}
801553e7af2d508bd5ee88ffa997fb3b
  lineC_cs :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "\n\
                   \\r"#) -}
1f388bfd690d0c2e8016101d540e5f5a
  parens ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity a
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String u Data.Functor.Identity.Identity a
  {- Unfolding: (\ @ u @ a8 ->
                 case JackParser.Lexer.lexer
                        @ u of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds17 @ a8 }) -}
426f275313eebdefc96aa71c4e1e86ba
  rBOp :: Text.Parsec.String.Parser JackParser.Lexer.RBOp
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                JackParser.Lexer.rBOp1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <JackParser.Lexer.RBOp>_R)) -}
fe2d55dcc672b59703f6fe5247c221ec
  rBOp1 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (JackParser.Lexer.RBOp
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (JackParser.Lexer.RBOp
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   eta1 :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta2 :: JackParser.Lexer.RBOp
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: JackParser.Lexer.RBOp
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Combinator.choice3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ JackParser.Lexer.RBOp
                   JackParser.Lexer.rBOp2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
372fbef9eccee6dab4d87ee43d3989ec
  rBOp2 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.RBOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.RBOp)
                   JackParser.Lexer.rBOp7
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.RBOp>_R))
                   JackParser.Lexer.rBOp3) -}
f36382d75ee7ad7359dbd9fcb941a3f9
  rBOp3 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.RBOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.RBOp)
                   JackParser.Lexer.rBOp6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.RBOp>_R))
                   JackParser.Lexer.rBOp4) -}
5449d038287184603c77d95925b87518
  rBOp4 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.RBOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.RBOp)
                   JackParser.Lexer.rBOp5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.RBOp>_R))
                   (GHC.Types.[]
                      @ (Text.Parsec.Prim.ParsecT
                           GHC.Base.String
                           ()
                           Data.Functor.Identity.Identity
                           JackParser.Lexer.RBOp))) -}
d779171813cdfe8bff88a5e3bf1b6cd1
  rBOp5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.RBOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.RBOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.RBOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.RBOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.rBOp_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Gt
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Gt
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
094118275dc2b7caa4f4f02a3f531c2e
  rBOp6 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.RBOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.RBOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.RBOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.RBOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.rBOp_m2
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Lt
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Lt
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
f9fbd02a02d9700e50afb4f112db3f6b
  rBOp7 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.RBOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.RBOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.RBOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.RBOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.rBOp_m3
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Eq
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Eq
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
27b8788631011e58088ee5f24b46294f
  rBOp_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds4 JackParser.Lexer.languageDef12 }) -}
8ad642ccb6332803a339c560ab4d4123
  rBOp_m2 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds4 JackParser.Lexer.languageDef13 }) -}
0293299ac32d590d77b5ff226bfd9747
  rBOp_m3 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds4 JackParser.Lexer.languageDef11 }) -}
a4c5d1c80412e2aa942e205b50ddcb67
  reserved ::
    GHC.Base.String
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String u Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ u ->
                 case JackParser.Lexer.lexer
                        @ u of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 }) -}
f77e2558e519769dc85a796b2b7a79ff
  reservedOp ::
    GHC.Base.String
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String u Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ u ->
                 case JackParser.Lexer.lexer
                        @ u of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds4 }) -}
b268e51722b59a8f5f862cf4aa3f7915
  scope :: Text.Parsec.String.Parser JackParser.Lexer.Scope
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                JackParser.Lexer.scope1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <JackParser.Lexer.Scope>_R)) -}
4a414b42ff45f02a2f3d1b35fa6c94cf
  scope1 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (JackParser.Lexer.Scope
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (JackParser.Lexer.Scope
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   eta1 :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta2 :: JackParser.Lexer.Scope
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: JackParser.Lexer.Scope
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Combinator.choice3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ JackParser.Lexer.Scope
                   JackParser.Lexer.scope2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
dc9699b50e3f82e872c4fd0477ffa27f
  scope2 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.Scope]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.Scope)
                   JackParser.Lexer.scope7
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.Scope>_R))
                   JackParser.Lexer.scope3) -}
c648dce1ea80971cf6aa049abd285358
  scope3 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.Scope]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.Scope)
                   JackParser.Lexer.scope6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.Scope>_R))
                   JackParser.Lexer.scope4) -}
eba301eae262586bcc6bfd6f1267d6cb
  scope4 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.Scope]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.Scope)
                   JackParser.Lexer.scope5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.Scope>_R))
                   (GHC.Types.[]
                      @ (Text.Parsec.Prim.ParsecT
                           GHC.Base.String
                           ()
                           Data.Functor.Identity.Identity
                           JackParser.Lexer.Scope))) -}
d8cdae2ef94bba542101bf6213193e30
  scope5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.Scope
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.Scope
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.Scope
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.Scope
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.scope_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Local
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Local
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
aec976a1a486785ed7026574499bb5e5
  scope6 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.Scope
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.Scope
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.Scope
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.Scope
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.scope_m2
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Static
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Static
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
f9d4ed9506de79b37bc11df4ea866d30
  scope7 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.Scope
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.Scope
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.Scope
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.Scope
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.scope_m3
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Field
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Field
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
816fd5df0056366dbfdc0dedfa3760a8
  scope_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef49 }) -}
b0348d7a93f2cf17f586202720c7b546
  scope_m2 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.$fShowScope3 }) -}
7c50b8e4144bf455d8532a88afc157d6
  scope_m3 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef48 }) -}
fb91e6b66c2d41fcfcdef39d83116c63
  semi ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity GHC.Base.String
  {- Unfolding: (\ @ u ->
                 case JackParser.Lexer.lexer
                        @ u of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds22 }) -}
fcd28add16f98642153096dcebfc7b25
  stringLiteral ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity GHC.Base.String
  {- Unfolding: (\ @ u ->
                 case JackParser.Lexer.lexer
                        @ u of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds6 }) -}
4b5300db61dda3a5486476ccabaca0af
  ttypes :: Text.Parsec.String.Parser JackParser.Lexer.TType
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                JackParser.Lexer.ttypes1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <JackParser.Lexer.TType>_R)) -}
3c9cd8d58d46d51bb71fe45fc6f92e8a
  ttypes1 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (JackParser.Lexer.TType
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (JackParser.Lexer.TType
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   eta1 :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta2 :: JackParser.Lexer.TType
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: JackParser.Lexer.TType
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Combinator.choice3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ JackParser.Lexer.TType
                   JackParser.Lexer.ttypes2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
85befcd6db35f2860c582fffcccbc2ec
  ttypes10 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.TType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.TType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.TType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.TType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.ttypes_m3
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.languageDef43
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.languageDef43
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
b0b43e615fd9c6e8e99895d27d9c3771
  ttypes11 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.TType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.TType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.TType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.TType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.ttypes_m4
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.languageDef41
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.languageDef41
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
8330b1756835423bafdc22a3d4b20316
  ttypes2 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.TType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.TType)
                   JackParser.Lexer.ttypes11
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.TType>_R))
                   JackParser.Lexer.ttypes3) -}
1301824a994c8904016c8f037259d28e
  ttypes3 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.TType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.TType)
                   JackParser.Lexer.ttypes10
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.TType>_R))
                   JackParser.Lexer.ttypes4) -}
a29e6c73299f81e831ebf2b01459333e
  ttypes4 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.TType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.TType)
                   JackParser.Lexer.ttypes9
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.TType>_R))
                   JackParser.Lexer.ttypes5) -}
5e0d6c0a603261acb1413d1e85819ff7
  ttypes5 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.TType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.TType)
                   JackParser.Lexer.ttypes8
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.TType>_R))
                   JackParser.Lexer.ttypes6) -}
09b606c801ff38b0710b4aa40070647e
  ttypes6 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String
       ()
       Data.Functor.Identity.Identity
       JackParser.Lexer.TType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String
                        ()
                        Data.Functor.Identity.Identity
                        JackParser.Lexer.TType)
                   JackParser.Lexer.ttypes7
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <JackParser.Lexer.TType>_R))
                   (GHC.Types.[]
                      @ (Text.Parsec.Prim.ParsecT
                           GHC.Base.String
                           ()
                           Data.Functor.Identity.Identity
                           JackParser.Lexer.TType))) -}
cfad33c403f59b43613ef55b6827388d
  ttypes7 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.TType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.TType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.TType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.TType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <GHC.Base.String>_R)
                   @ b1
                   eta
                   (\ x :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      x
                      s2
                      (case s2 of wild1 { Text.Parsec.Prim.State ds37 ds38 ds39 ->
                       case ds38 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      x
                      s2
                      (case s2 of wild1 { Text.Parsec.Prim.State ds37 ds38 ds39 ->
                       case ds38 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4 }) -}
145ae9ae862bd560e45cf3c5892073b1
  ttypes8 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.TType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.TType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.TType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.TType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.ttypes_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.languageDef44
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.languageDef44
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
f05fb9805c13dc7a9436e31c8fc6b14d
  ttypes9 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.TType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.TType
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.TType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.TType
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.ttypes_m2
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.languageDef42
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.languageDef42
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
2fa1d720bc217f3df3bb19ba12d25078
  ttypes_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef44 }) -}
01828b4ae9459a1cf19c38db77b280d8
  ttypes_m2 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef42 }) -}
777aa00a98e92ab448ac53d6d37bf9e5
  ttypes_m3 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef43 }) -}
c3d46f3f4837bc655fa6d2f18b52634b
  ttypes_m4 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds2 JackParser.Lexer.languageDef41 }) -}
555d201778b53f37e5bb7abbcf084f5d
  uAOp :: Text.Parsec.String.Parser JackParser.Lexer.UAOp
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                JackParser.Lexer.uAOp1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <JackParser.Lexer.UAOp>_R)) -}
9735c7201f5ec29f89e7a5bbc1fd7bed
  uAOp1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.UAOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.UAOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.UAOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.UAOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.bAOp_m3
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Neg
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Neg
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
5890f10b068df2d196eaaf476a822b48
  uBOp :: Text.Parsec.String.Parser JackParser.Lexer.UBOp
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                JackParser.Lexer.uBOp1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <JackParser.Lexer.UBOp>_R)) -}
9123bb47cac97cccc183d65f04c14fa7
  uBOp1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (JackParser.Lexer.UBOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (JackParser.Lexer.UBOp
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: JackParser.Lexer.UBOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: JackParser.Lexer.UBOp
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 JackParser.Lexer.uBOp_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      JackParser.Lexer.Not
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      JackParser.Lexer.Not
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
4e1147190258528ea59655588116db75
  uBOp_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case JackParser.Lexer.lexer
                        @ () of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds4 JackParser.Lexer.languageDef14 }) -}
33c48235e72c8c0c9a3474b8132cbf78
  whiteSpace ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ u ->
                 case JackParser.Lexer.lexer
                        @ u of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds16 }) -}
instance GHC.Classes.Eq [JackParser.Lexer.BAOp]
  = JackParser.Lexer.$fEqBAOp
instance GHC.Classes.Eq [JackParser.Lexer.BBOp]
  = JackParser.Lexer.$fEqBBOp
instance GHC.Classes.Eq [JackParser.Lexer.BOp]
  = JackParser.Lexer.$fEqBOp
instance GHC.Classes.Eq [JackParser.Lexer.Boolean]
  = JackParser.Lexer.$fEqBoolean
instance GHC.Classes.Eq [JackParser.Lexer.FunType]
  = JackParser.Lexer.$fEqFunType
instance GHC.Classes.Eq [JackParser.Lexer.RBOp]
  = JackParser.Lexer.$fEqRBOp
instance GHC.Classes.Eq [JackParser.Lexer.Scope]
  = JackParser.Lexer.$fEqScope
instance GHC.Classes.Eq [JackParser.Lexer.UAOp]
  = JackParser.Lexer.$fEqUAOp
instance GHC.Classes.Eq [JackParser.Lexer.UBOp]
  = JackParser.Lexer.$fEqUBOp
instance GHC.Classes.Eq [JackParser.Lexer.UOp]
  = JackParser.Lexer.$fEqUOp
instance GHC.Show.Show [JackParser.Lexer.BAOp]
  = JackParser.Lexer.$fShowBAOp
instance GHC.Show.Show [JackParser.Lexer.BBOp]
  = JackParser.Lexer.$fShowBBOp
instance GHC.Show.Show [JackParser.Lexer.BOp]
  = JackParser.Lexer.$fShowBOp
instance GHC.Show.Show [JackParser.Lexer.Boolean]
  = JackParser.Lexer.$fShowBoolean
instance GHC.Show.Show [JackParser.Lexer.FunType]
  = JackParser.Lexer.$fShowFunType
instance GHC.Show.Show [JackParser.Lexer.RBOp]
  = JackParser.Lexer.$fShowRBOp
instance GHC.Show.Show [JackParser.Lexer.Scope]
  = JackParser.Lexer.$fShowScope
instance GHC.Show.Show [JackParser.Lexer.UAOp]
  = JackParser.Lexer.$fShowUAOp
instance GHC.Show.Show [JackParser.Lexer.UBOp]
  = JackParser.Lexer.$fShowUBOp
instance GHC.Show.Show [JackParser.Lexer.UOp]
  = JackParser.Lexer.$fShowUOp
"SPEC/JackParser.Lexer $dmshowsPrec @ BBOp" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                        JackParser.Lexer.BBOp
  GHC.Show.$dmshowsPrec @ JackParser.Lexer.BBOp $dShow
  = JackParser.Lexer.$fShowBBOp_$s$dmshowsPrec
"SPEC/JackParser.Lexer $dmshowsPrec @ Boolean" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                           JackParser.Lexer.Boolean
  GHC.Show.$dmshowsPrec @ JackParser.Lexer.Boolean $dShow
  = JackParser.Lexer.$fShowBoolean_$s$dmshowsPrec
"SPEC/JackParser.Lexer $dmshowsPrec @ UAOp" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                        JackParser.Lexer.UAOp
  GHC.Show.$dmshowsPrec @ JackParser.Lexer.UAOp $dShow
  = JackParser.Lexer.$fShowUAOp_$s$dmshowsPrec
"SPEC/JackParser.Lexer $dmshowsPrec @ UBOp" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                        JackParser.Lexer.UBOp
  GHC.Show.$dmshowsPrec @ JackParser.Lexer.UBOp $dShow
  = JackParser.Lexer.$fShowUBOp_$s$dmshowsPrec
"SPEC/JackParser.Lexer $dmshowsPrec @ UOp" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                       JackParser.Lexer.UOp
  GHC.Show.$dmshowsPrec @ JackParser.Lexer.UOp $dShow
  = JackParser.Lexer.$fShowUOp_$s$dmshowsPrec
"SPEC/JackParser.Lexer read @ IntLit" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                  JackParser.Lexer.IntLit
  Text.Read.read @ GHC.Types.Int $dRead = JackParser.Lexer.$sread
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

